import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm
from time import sleep


global dt
global psi
global c
global v
global n
global k
global radius
global rho_o
global control_signal
global control_hold
global control_rate


class traj_solver():
    control_time_delay = 0.1
    control_hold = 0
    dt = 0.1
    control_rate = int(control_time_delay/dt)
    c = 1.1
    psi = np.pi*(3.01/2)

    v = 1
    n = 1
    k = 0.1
    radius = 0.6
    lambda_v = np.exp((2*v)/(k*radius*np.pi))
    rho_o = ((c-1)*radius)/((lambda_v*c) - 1)
    control_signal = []
        

    def g_function(xb,xv,c,rho_o):
        rho_v = np.array(xb) - np.array(xv)
        rho = np.linalg.norm(rho_v)
        g = np.log((((c-1)*rho) + rho_o)/(c*rho_o))
        if (rho<0.000000001):
            g = 0
        return g
    def alpha_d(gamma,psi):
        if ((gamma>=0)and (gamma <=psi)):
            return gamma
        elif ((gamma>psi)and (gamma <2*np.pi)):
            return gamma - 2*np.pi
        else :
            print("Error in gamma value" + gamma)

    def u_t(xv,xb,heading):
        gamma = get_angle(xb[0] - xv[0],xb[1] - xv[1]) - heading
        while (gamma>2*np.pi):
            gamma = gamma -2*np.pi
        while (gamma<0):
            gamma = gamma + 2*np.pi
        #print(np.rad2deg(gamma))
        alpha = alpha_d(gamma,psi)

        g = g_function(xb,xv,c,rho_o)
        
        u = k*g*alpha
        control_signal.append(u)
        return np.array([u])

    def velocity(t,n):
        return np.ones(n)*v
    def adjust_angle(x,n):
        for i in range (n):
            while (x[(3*i)+2]>2*np.pi):
                x[(3*i)+2] = x[(3*i)+2] -2*np.pi
            while (x[(3*i)+2]<0):
                x[(3*i)+2] = x[(3*i)+2] + 2*np.pi
        return x

    def f_unicycle(t,x,n):
        xb = np.array([-0.7 , 0])
        v_vec = velocity(t,n)
        global control_hold
        # print(int(t/dt)%control_rate)
        if int(t/dt)%control_rate == 0 :
            theta_dot_vec = u_t(x[0:2],xb,x[2])
            control_hold = theta_dot_vec
        else:
            theta_dot_vec = control_hold
        rhs = []
        for i in range(n):
            v = v_vec[i]
            theta_dot = theta_dot_vec[i]
            theta = x[(3*i) + 2]
            rhs.append([(v*np.cos(tvheta)),(v*np.sin(theta)),(theta_dot)])

        rhs = np.array(rhs)
        rhs = rhs.flatten()
        return rhs
    def rk4_step(f,x,t,dt,n):
        k1 = f(t,x,n)
        k2 = f(t + (0.5*dt),x + (0.5*k1*dt),n)
        k3 = f(t + (0.5*dt),x + (0.5*k2*dt),n)
        k4 = f(t + dt,x + (k3*dt),n)

        return dt*((k1 + (2*k2) + (2*k3) + k4)/6)


    def get_angle(dx,dy):
        theta = np.arctan2(dy,dx)
        if(theta<0):
            theta = theta + 2*np.pi
        return theta


def get_trajectory():
    x0 = np.array([0,0,1.57])
    n = 1
    traj = [x0]
    x = x0
    t = 0
    T = 500
    while t < 500:
        dx = rk4_step(f_unicycle,x,t,dt,n)
        x = x + dx
        x = adjust_angle(x,n)
        t = t + dt
        #traj.append(x)

        print(f"coordinate")
    